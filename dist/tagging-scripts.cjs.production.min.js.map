{"version":3,"file":"tagging-scripts.cjs.production.min.js","sources":["../src/utils.ts","../src/dynamic.ts","../src/push.ts","../src/pageble.ts","../src/auth.ts","../src/infos.ts","../src/index.ts","../src/clickable.ts"],"sourcesContent":["import { isObject, reduce, merge } from 'lodash';\n\nlet __TaggingConfiguration: any;\n\nexport const flattenKeys = (\n  obj: Record<string, unknown>,\n  path: string[] = []\n): Record<string, string> =>\n  !isObject(obj)\n    ? { [path.join('.')]: obj }\n    : reduce(\n        obj,\n        (cum: any, next: any, key: any) =>\n          merge(\n            cum,\n            flattenKeys(next as Record<string, unknown>, [...path, key])\n          ),\n        {}\n      );\n\nexport const replace = (str: string, obj: any) =>\n  str.replaceAll(/\\{([^}]+)\\}/gi, (_, a) =>\n    a.split('.').reduce((b: any, c: any) => b?.[c], obj)\n  );\nexport const getPictureFromDom = (domTarget: any) => {\n  const { dataset, classList = [], id } = domTarget;\n  return {\n    dataset,\n    classList,\n    id,\n  };\n};\n\nexport const getPathname = (locationInstance?: any) => {\n  const location = locationInstance || window.location;\n  const { hash } = getAppConfig();\n  if (hash) {\n    return location.hash.replace('#', '');\n  }\n  return location.pathname;\n};\n\nexport const getAppConfig = () => {\n  return __TaggingConfiguration;\n};\n\nexport const setAppConfig = (config: any) => {\n  __TaggingConfiguration = config;\n};\n","import { set, get } from 'lodash';\nlet dynamic: any = {};\n\nexport const getData = (key: string): any => {\n  return get(dynamic, key, {});\n};\n\nexport const setData = (key: string, data: any) => {\n  set(dynamic, key, data);\n};\n","import { set, get } from 'lodash';\nimport * as utils from './utils';\n\nexport const pushEvent = (scope: any, data: any) => {\n  const { eventLabel, pushTargets = {} } = utils.getAppConfig();\n  // push event\n  set(window, '__TAG_DATA__LAYER', data);\n\n  const eventName = get(scope, eventLabel, scope.type || 'event');\n\n  const targetPipe: string[] = Object.values(pushTargets);\n  targetPipe.forEach(pushFn => {\n    // new function with event name and data as arguments\n    const pushFnWithArgs = new Function('eventName', 'data', pushFn);\n    pushFnWithArgs(eventName, data);\n  });\n};\n","import * as utils from './utils';\nimport * as auth from './auth';\nimport * as infos from './infos';\nimport * as R from 'ramda';\nimport { isEmpty, merge, set } from 'lodash';\nimport * as dynamic from './dynamic';\nimport * as push from './push';\n\nexport const runJob = () => {\n  const page = getActivedPage();\n  if (!page || !isEmpty(page?.dynamicKeys)) {\n    return;\n  }\n  const output = getRuleOutput(true);\n  if (isEmpty(output)) {\n    return;\n  }\n  push.pushEvent(page, output);\n};\n\nexport const runJobWithDynamicData = () => {\n  const output = getRuleOutput(true);\n  if (isEmpty(output)) {\n    return;\n  }\n  push.pushEvent(getActivedPage(), output);\n};\n\nexport const findPage = R.memoizeWith(R.toUpper, (identifier: string): any => {\n  const config = utils.getAppConfig();\n  return R.find(R.propEq(identifier, 'id'))(config.pages);\n});\n\nexport const getActivedPage = () => {\n  const pathname = utils.getPathname();\n  const page = findPage(pathname);\n  if (!page) {\n    return;\n  }\n  return page;\n};\n\nexport const getActivePageTag = () => {\n  const page = getActivedPage();\n  if (!page) {\n    return;\n  }\n  return page.tag;\n};\n\nexport const getRuleOutput = (decode?: boolean) => {\n  const page = getActivedPage();\n  if (!page) {\n    return;\n  }\n  const { rules, tag, dynamicKeys } = page;\n  const dynamicData = dynamic.getData(utils.getPathname());\n  const data = merge({}, dynamicData, tag, auth.getData(), infos.getData());\n  if (!R.isEmpty(dynamicKeys)) {\n    const keysOfCurrentPage = Object.keys(dynamicData);\n    const diff = R.difference(dynamicKeys, keysOfCurrentPage);\n    if (!R.isEmpty(diff)) {\n      console.warn('[page]missing dynamic keys', diff);\n    }\n  }\n  // pending runtime data\n  const flattenRules = utils.flattenKeys(rules);\n  const output = R.mapObjIndexed(value => {\n    return utils.replace(value, data);\n  }, flattenRules);\n\n  if (decode) {\n    const decodeOutput = {};\n    R.forEachObjIndexed((value, key) => {\n      set(decodeOutput, key, value);\n    }, output);\n    return decodeOutput;\n  }\n\n  return output;\n};\n","import * as utils from './utils';\n\nlet auth: any;\n\nexport const getData = (): any => {\n  return auth || utils.getAppConfig().auth || {};\n};\n\nexport const setData = (data: any) => {\n  auth = data;\n};\n","import * as utils from './utils';\n\nlet infos: any;\n\nexport const getData = () => {\n  return infos || utils.getAppConfig().infos || {};\n};\n\nexport const setData = (data: any) => {\n  infos = data;\n};\n","// import config from './config';\nimport * as clickable from './clickable';\nimport * as pageble from './pageble';\nimport * as utils from './utils';\n\nconst taggingRun = (__TaggingConfiguration: any) => {\n  if (__TaggingConfiguration) {\n    console.log('Tagging is running');\n\n    var pushState = window.history.pushState;\n    window.history.pushState = function() {\n      const beforeIdentifier = utils.getPathname(window.location);\n      pushState.apply(window.history, arguments as any);\n      const afterIdentifier = utils.getPathname(window.location);\n      if (beforeIdentifier !== afterIdentifier) {\n        pageble.runJob();\n      }\n    };\n\n    window.addEventListener('popstate', () => {\n      pageble.runJob();\n    });\n\n    document.addEventListener(\n      'click',\n      e => {\n        clickable.runJob(utils.getPictureFromDom(e.target));\n      },\n      true\n    );\n  }\n};\n\nexport default taggingRun;\n","import * as R from 'ramda';\nimport * as pageble from './pageble';\nimport * as utils from './utils';\nimport * as auth from './auth';\nimport * as infos from './infos';\nimport { merge, set } from 'lodash';\nimport * as push from './push';\n\nexport const runJob = ({ dataset = {}, classList, id }: any) => {\n  // get actived page\n  const page = pageble.getActivedPage();\n  if (!page) {\n    return;\n  }\n\n  // get actived button\n  const button = getTargetButton({ classList, id }, page);\n\n  if (!button) {\n    return;\n  }\n  // get page output, get button output\n  const resultOfPage = pageble.getRuleOutput() || {};\n  const resultOfButton = getRuleOutput(button, false, dataset);\n  const result = merge({}, resultOfPage, resultOfButton);\n\n  const data = {};\n  R.forEachObjIndexed((value, key) => {\n    set(data, key, value);\n  }, result);\n\n  push.pushEvent(button, data);\n};\n\nexport const getRuleOutput = (button: any, decode: boolean, dataset: any) => {\n  const { rules, tag, dynamicKeys } = button;\n\n  if (!R.isEmpty(dynamicKeys)) {\n    const keysOfCurrentButton = Object.keys(dataset);\n    const diff = R.difference(dynamicKeys, keysOfCurrentButton);\n    if (!R.isEmpty(diff)) {\n      console.warn('[clickable]missing dynamic keys', diff);\n    }\n  }\n\n  const pageTag = pageble.getActivePageTag();\n  const data = merge(\n    {},\n    dataset,\n    pageTag,\n    tag,\n    auth.getData(),\n    infos.getData()\n  );\n  // pending runtime data\n  const flattenRules = utils.flattenKeys(rules);\n  const output = R.mapObjIndexed(value => {\n    return utils.replace(value, data);\n  }, flattenRules);\n\n  if (decode) {\n    const decodeOutput = {};\n    R.forEachObjIndexed((value, key) => {\n      set(decodeOutput, key, value);\n    }, output);\n    return decodeOutput;\n  }\n  return output;\n};\n\nexport const getTargetButton = (picture: any, page?: any) => {\n  if (!page) {\n    page = pageble.getActivedPage();\n  }\n  if (!page) {\n    return;\n  }\n  const button: any = R.find(\n    R.anyPass([\n      R.propEq(picture.id, 'id'),\n      R.propSatisfies(v => picture.classList?.contains(v), 'class'),\n    ])\n  )(page.actions.clicks);\n\n  if (!button) {\n    return;\n  }\n  return button;\n};\n"],"names":["flattenKeys","obj","path","isObject","reduce","cum","next","key","merge","concat","_ref","join","replace","str","replaceAll","_","a","split","b","c","getPathname","locationInstance","window","location","pathname","dynamic","pushEvent","scope","data","eventLabel","utils","set","eventName","get","type","Object","values","forEach","pushFn","Function","pushFnWithArgs","runJob","page","getActivedPage","isEmpty","dynamicKeys","output","getRuleOutput","push","findPage","R","identifier","pages","decode","rules","tag","dynamicData","keysOfCurrentPage","keys","diff","console","warn","flattenRules","value","decodeOutput","__TaggingConfiguration","log","pushState","history","beforeIdentifier","apply","arguments","afterIdentifier","pageble","addEventListener","document","e","domTarget","_domTarget$classList","dataset","_ref$dataset","classList","id","button","picture","v","_picture$classList","contains","actions","clicks","getTargetButton","resultOfPage","resultOfButton","keysOfCurrentButton","pageTag","result","clickable","target"],"mappings":"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"}
